WEBVTT

00:00.000 --> 00:11.200
All right, everyone. Welcome to another episode of the Twomol AI podcast. I am your host Sam

00:11.200 --> 00:16.960
Charrington. And today I'm joined by Basi Filiman. Basi is vice president and general manager

00:16.960 --> 00:21.920
of machine learning and AI at Amazon. Before we get going, be sure to take a moment to hit that

00:21.920 --> 00:26.560
subscribe button wherever you're listening to today's show. Basi, welcome to the podcast.

00:26.560 --> 00:32.160
Thanks for having me, Sam. I'm super excited for this discussion for those who, well, you don't

00:32.160 --> 00:38.320
know yet, but you're about to know this is a very special interview because it is the first in person

00:38.320 --> 00:48.640
interview I've done since NURBS in Vancouver in 2019. I happen to be in New York for some meetings

00:48.640 --> 00:55.840
with AWS as was Basi. And here we are. And we're going to spend some time today talking about

00:55.840 --> 01:02.080
the recently announced Amazon code whisperer coding companion. And as a bonus,

01:02.080 --> 01:06.560
Basi will be doing a demo for me that you'll be able to catch on YouTube towards the end of

01:06.560 --> 01:12.160
our interview. Basi, let's get started with some background. Tell us a little bit about your role

01:12.160 --> 01:21.040
at AWS. Yeah, so I'm vice president at AWS and I'm responsible for AI services. My background is

01:21.040 --> 01:26.080
machine learning. Back in the 90s, I did a PhD in computer science from the University of Maryland.

01:27.120 --> 01:32.240
And I chose to do it in machine learning. It wasn't a common thing to do at that time. A lot of

01:32.240 --> 01:37.360
my friends were asking me what, what, what the heck is machine learning? Like, why are you doing

01:37.360 --> 01:42.240
machine learning? You should be doing databases or you should be doing operating systems.

01:42.960 --> 01:47.760
But I'm, I have to say that I'm the one with the last laugh. I'm kind of glad that I did it

01:47.760 --> 01:54.240
at that time. It's serving me really well right now. And your role at AWS, your, what,

01:54.240 --> 01:59.760
what aspects of ML and AI are you responsible for? Yeah, I'm responsible for a lot of the services

01:59.760 --> 02:03.840
that we have at the top layer of the stack. Are you familiar, Sam, with the, with the three layers

02:03.840 --> 02:09.120
of the stack, the way we think about machine learning? Absolutely. Yeah. So, but we can, we can

02:09.120 --> 02:14.880
recap that infrastructure at the bottom developer or data sciences, focus tools in the middle. Right.

02:14.880 --> 02:20.000
And cognitive services for lack of a better order. AI services at the top. Right. Right.

02:20.000 --> 02:24.480
And I'm responsible with the top layer there. Okay. AI services layer. It's not just cognitive.

02:24.480 --> 02:29.120
There's a set of cognitive language services at the top layer. There's also a bunch of

02:29.120 --> 02:34.640
industrial services. So, there's a whole variety of services at the top layer of the stack,

02:34.640 --> 02:39.120
the whole, the difference though with the middle layer is that the top layer is more managed

02:39.120 --> 02:44.240
experience and people using those services don't have to be experts in machine learning.

02:44.240 --> 02:48.720
All they need to know is, here's my application and here's how it's going, I'm going to make it

02:48.720 --> 02:55.120
smarter. And I need this capability that I could just plug into my application to make it smarter.

02:55.120 --> 03:00.960
And then they can just go and use it just like they do today. They, they access a web service for

03:00.960 --> 03:07.520
compute or the access of web service for storage. They can now access an AI service in the same

03:07.520 --> 03:12.000
exact way. And they can insert it into their own applications and make their applications faster.

03:12.000 --> 03:18.880
Mm-hmm. So, let's dig in a little bit into the distinction between cognitive and industry.

03:18.880 --> 03:26.640
So, the non-cognitive services would be things like, I know AWS has, for example,

03:26.640 --> 03:31.360
medical transcription. Would you consider that non-cognitive or are you thinking like the call

03:31.360 --> 03:37.760
center AI or? Okay, okay. Let me describe that to you in more detail. When we started out,

03:37.760 --> 03:43.760
the first few services we launched, I would call them like foundational to any machine learning

03:44.560 --> 03:52.080
business or a unit. And they're foundational in the sense that they capture a lot of the cognitive

03:52.080 --> 03:57.920
things that humans are able to do. So, to give you an example, we started with Lex Lexes,

03:57.920 --> 04:03.760
sort of the guts of Alexa. Essentially, it's the two A's removed from Alexa. And what's inside

04:03.760 --> 04:09.280
is Lex. Not many people know that, but now they do. It all makes sense. Right. Right. And Lexes are

04:09.280 --> 04:15.440
conversational AI platform. And what people can do with it is they could build their own Alexa's

04:15.440 --> 04:21.280
if they wanted to or they could build a chatbot and insert it into their website. And so,

04:21.280 --> 04:26.320
that Lexes something that would understand both text input as well as speech input. So,

04:26.320 --> 04:31.920
they build a bot just once and then they can insert it into a call center conversation so that

04:31.920 --> 04:38.160
it can take the call and maybe take care of the customer that's calling. So, that's Lex,

04:38.160 --> 04:42.800
which is a conversational part. And that's definitely a cognitive service. We call it a language

04:42.800 --> 04:49.280
service. I think Gartner calls it a language service too. So, we also have Polly. Polly is our

04:49.280 --> 04:56.640
text-to-speech service. Alexa's voice is actually a Polly voice. But customers now have the

04:56.640 --> 05:03.760
capability to have their own voices. They can pick from one of the many languages that we support

05:03.760 --> 05:08.000
and the different kinds of voices we may have for each of the languages. And then they could just

05:08.000 --> 05:13.200
use it for various applications. And a common one they use it for is they just put this thing on

05:13.200 --> 05:18.320
a web page. And so, when people are driving their cars, they can just listen to what's on the web

05:18.320 --> 05:22.960
page and Polly is going to narrate it for you. Right. So, that's another cognitive service.

05:22.960 --> 05:28.960
Then we've got Translate, Amazon Translate, which is a document translation. You can go from

05:28.960 --> 05:34.880
one language to another. And we've gotten to very high quality these days in terms of translation.

05:34.880 --> 05:40.960
So, you could do a lot of cool things with that. Then we've got Transcribe, which is a speech-to-text.

05:40.960 --> 05:46.880
We talked about text-to-speech before with Polly. But this one is a speech-to-text. And so,

05:46.880 --> 05:54.400
this is useful for you to understand what's being said in a conversation. So, that is another

05:54.400 --> 05:59.200
cognitive service. And then we've got yet another one called Comprehend, which is a natural language

05:59.200 --> 06:03.680
processing service. And it's got all kinds of things you could do with it, like sentiment.

06:03.680 --> 06:09.680
Given a piece of unstructured text, it'll tell you what the sentiment is. Is it a negative sentiment?

06:09.680 --> 06:15.360
Is it a positive sentiment? So, customers often they use it for reviews. Like, the capture

06:15.360 --> 06:20.800
reviews and then they run it through Comprehend. And they understand, like, are people excited about

06:20.800 --> 06:26.320
what whatever it is that the review was for or are they unhappy about it? And we've got things

06:26.320 --> 06:32.000
like targeted sentiment. So, you know, in the same sentence, you could say that the food was great,

06:32.000 --> 06:37.120
but the service was lousy. And so, that's that's multiple sentiments within the same sentence.

06:37.680 --> 06:42.960
That's the kind of stuff you could do with Comprehend. You could also do things with Comprehend where

06:42.960 --> 06:47.360
you can extract entities of interest from unstructured text. Like, let's say you see

06:48.000 --> 06:53.440
there's an article on one company acquiring another company. You could now just look at that

06:53.440 --> 06:59.600
news article and you can extract things like which was the company that was acquired,

06:59.600 --> 07:04.960
who was the CEO of that company? What was the transaction value? All of those kinds of things

07:04.960 --> 07:11.360
can be extracted. So, that's kind of what Comprehend does. It helps you understand unstructured text.

07:11.360 --> 07:16.160
Right? So, these are sort of the language or the cognitive services that we have. And that's what

07:16.160 --> 07:20.480
we started with at the beginning. These are the basic foundational blocks you would need to build

07:20.480 --> 07:30.160
anything else. And then, more recently, we've added domain specific services. Like, let me take one

07:30.160 --> 07:37.360
industrial service, for example. Monitoron is an example of it. And this is an AWS service that's,

07:37.360 --> 07:43.280
it includes a piece of hardware that comes with it. The hardware is essentially a temperature

07:43.280 --> 07:49.120
and vibration sensor. And it's meant for shop floor technicians that want to monitor

07:49.760 --> 07:54.800
their equipment on this factory floor. And they want to do predictive maintenance. So, they

07:54.800 --> 07:59.600
buy this piece of hardware from us and they attach it to some portion of the machine that they

07:59.600 --> 08:07.360
want to monitor. And what we do is we learn the behavior of that part of the machine in terms

08:07.360 --> 08:13.440
of vibration and temperature, which is what the sensors are in that unit. And so, over time,

08:13.440 --> 08:19.200
we'll be able to tell the person, the user, the customer, if there's a deviation in behavior.

08:20.160 --> 08:28.160
And because vibration is something that it predicts, it's something that it'll tell you

08:28.160 --> 08:33.200
before things are going to fail. It has that predictive nature. So, we're able to actually

08:33.200 --> 08:39.520
detect issues way before they actually happen. So, for example, our fulfillment centers,

08:39.520 --> 08:44.720
we have conveyor belts in our fulfillment centers to move the products around. And so,

08:44.720 --> 08:49.280
it's very important for those belts to keep running. And there's a lot of rotating parts there.

08:49.280 --> 08:54.720
And we use these, we use Monitoron there to monitor the health, the whole conveyor system.

08:54.720 --> 09:00.400
And we've been able to catch failures like two weeks before they actually happened.

09:01.120 --> 09:05.760
So, this essentially allows customers to plan the maintenance, rather than, you know,

09:05.760 --> 09:13.680
react in a, it's going to be chaos if it just happens and they are not prepared for it. So,

09:14.400 --> 09:20.640
that's a very clear, that's, it's not cognitive. It's something that is specific to the domain.

09:20.640 --> 09:26.560
And it's a large enough segment there. And lots of customers have moving parts.

09:27.120 --> 09:33.440
And they have equipment that they can't afford to fail. And so, that's a place where things

09:33.440 --> 09:39.520
like Monitoron is being used. And to come back to your question on the medical transcription thing,

09:39.520 --> 09:43.920
that's just an extension of the transcription that we have. It just applies to the medical domain.

09:43.920 --> 09:48.800
So, I would say that that is a cognitive service because it has to do with, you know,

09:48.800 --> 09:54.400
the speech and it has to do with understanding speech. So, those are the kinds of things we have.

09:54.400 --> 09:58.240
We have also other kinds of services up there at the top layer at the stack. We've got

09:58.800 --> 10:06.000
things like contact lens for Amazon Connect. And what contact lens does is it's a higher level

10:06.000 --> 10:12.080
abstraction. It uses transcribe underneath the scenes. It uses comprehend underneath the scenes.

10:12.080 --> 10:17.200
But it was built for the call center. And if you're a call center customer,

10:17.200 --> 10:22.640
what you're interested in is you just want to know why are customers calling me, right? You want

10:22.640 --> 10:28.240
to know that. You want to know how every call is going. Is it going? And by the way, you want to

10:28.240 --> 10:33.120
know this real time as it's happening, but you may also want to do it post call, which is called

10:33.120 --> 10:37.840
post call analytics. You want to know how your agents are doing. How are they responding? Are they

10:37.840 --> 10:41.600
actually helping the customer? Are they saying the right things at the right time, right?

10:41.600 --> 10:47.520
So, you could do all of those things. And that's what contact lens does. It actually

10:47.520 --> 10:53.520
implements the actual, it takes the business problem and just implements it using a combination

10:53.520 --> 10:58.080
of these foundational services that I talked about. So, we've also got some of those at the top

10:58.080 --> 11:04.240
layer at the stack. And then I've got one more thing. And it's called Amazon Kendra.

11:04.240 --> 11:13.680
And that's about search. It's about enterprise search where you've got, if you're an enterprise,

11:14.320 --> 11:19.120
you've got a lot of documents within your enterprise. And these documents are typically siloed.

11:19.680 --> 11:24.560
They're not, they're not like the documents on the web where everything's linked to each other.

11:24.560 --> 11:29.280
And you know, you can figure out what people are clicking on and keep track of which documents

11:29.280 --> 11:34.320
are more interesting. Instead here, they're all siloed. They're sitting in different systems.

11:34.320 --> 11:40.160
Like they're sitting in SharePoint maybe or they're sitting on your wiki pages or

11:40.960 --> 11:49.440
they're sitting inside Salesforce. And so, it's always a much harder problem for employees to find

11:49.440 --> 11:54.800
things that they actually want to find within an enterprise. If you've, if you've ever tried

11:54.800 --> 12:01.600
the search systems that are at enterprises, they are pretty horrible. And the one that we used to

12:01.600 --> 12:06.480
have inside Amazon wasn't very good either before Kendra. So, and-

12:06.480 --> 12:10.800
This is a space that I know fairly well. Having worked at a startup that tried to solve this

12:10.800 --> 12:16.960
problem 20 something years ago. Okay, okay, all right. But it's like you're giving the

12:16.960 --> 12:22.320
pitch that we used to give back then. It's one of these problems that just, you know, hasn't been

12:22.320 --> 12:27.440
solved and probably won't ever be solved in the enterprise. Okay. Because it's such a difficult

12:27.440 --> 12:31.680
problem. Absolutely. It's a difficult problem. But I think our tech, the technology is there where

12:31.680 --> 12:35.440
we were able to solve it in a very good way. And I'll tell you the kinds of things you can do with

12:35.440 --> 12:40.560
Kendra. So Kendra is again, another higher level abstraction where it just focuses on the business

12:40.560 --> 12:44.960
problem, which is search, right? You need to be able to help people find what they're looking for

12:44.960 --> 12:49.760
and documents are sitting in different places. So, you can't use all the usual techniques.

12:49.760 --> 12:54.880
So, what Kendra does number one is it allows you to suck in all of the data from all of these systems.

12:54.880 --> 12:59.520
There's connectors, managed connectors. All you have to do is to provide credentials and it's

12:59.520 --> 13:04.080
going to suck in all of the data and also keep the access rights along with it so that you're not

13:04.080 --> 13:08.560
going to show up, they're not going to show up in search results for people that are not authorized

13:08.560 --> 13:13.440
to see certain kinds of documents. So it keeps, it not only sucks the data from these different

13:13.440 --> 13:18.000
systems, but it also keeps all the permissions intact so that it knows what to show and what not to

13:18.000 --> 13:24.720
show. The second thing Kendra does is it understands all of the documents like a human would after

13:24.720 --> 13:30.640
reading it. So now, anyone can ask a question and I'm not talking about keyword search. I'm talking

13:30.640 --> 13:37.680
about semantic search here. So I could actually say, where is the IT help desk at this Amazon building,

13:37.680 --> 13:43.200
right? I can just ask that question. And the answer is not going to be like a hundred links where

13:43.200 --> 13:48.320
I need to click on every single document and then hope I find this information in there. It's

13:48.320 --> 13:52.160
Kendra is actually going to tell me it's the fourth floor, right? Right up there. And of course,

13:52.160 --> 13:56.720
it's going to have all the links as well. The documents below like you're used to in a traditional

13:56.720 --> 14:01.680
search, but you don't have to go digging for the answer. If it's confident, it'll show you the

14:01.680 --> 14:06.880
answer right up there. And also in terms of relevance in the document, the documents being the

14:06.880 --> 14:12.320
right documents, even we can't use a lot of signals that are available on the web. We use a lot of

14:12.320 --> 14:18.640
clever techniques there. It's pre-trained on various domains. So it's going to perform really

14:18.640 --> 14:24.480
well out of the box. So there's a lot of our customers that love the ease of setting this up.

14:26.000 --> 14:31.760
We've also made it very easy to set up. You can ingest all of your documents with these

14:31.760 --> 14:37.360
connectors and immediately you've got to search application that you can just go in and try it out.

14:38.240 --> 14:41.840
And then of course, you can embed that into your own websites and things like that.

14:41.840 --> 14:45.840
So that's what can, and underneath the scenes, if you're interested in kind of underneath the

14:45.840 --> 14:51.200
scenes, there's a whole bunch of NLP models. That's what makes it happen. You said it was a hard

14:51.200 --> 14:56.160
problem and that's rightfully so. Yeah, we were using Verity and I think we started looking at

14:56.160 --> 15:02.720
autonomy. These are all text search engines and the problem that you described if a user getting

15:02.720 --> 15:09.600
back tons of links that match, but relevance was the difficult problem. And we were nowhere near

15:09.600 --> 15:14.800
at that time, summarization and some of the things that you described. Absolutely. And underneath

15:14.800 --> 15:22.080
the scenes, there's a whole bunch of models. There's a document ranking model. There's an FAQ model.

15:22.640 --> 15:27.520
There's a question answering model and all of these models sort of work together and all of the

15:27.520 --> 15:33.120
complexities is not, I mean, the user doesn't have to deal with all of our complexity and putting

15:33.120 --> 15:37.360
all of this together. We make sure that these things work seamlessly together. And of course,

15:37.360 --> 15:41.360
Kendra has like learning, like continuous learning. It gets better as more people use it.

15:42.480 --> 15:47.120
There's explicit feedback. There's a thumbs up, thumbs down on the search results. If somebody

15:47.120 --> 15:53.200
does click it, we'll keep track of it. It gets better for the enterprise or implicitly we can track,

15:53.680 --> 15:59.360
okay, they are clicking on this document in from the results. So maybe it wasn't the first one.

15:59.360 --> 16:04.720
It was the third one. And so those kinds of things make sure that it gets better over time,

16:04.720 --> 16:09.600
which is another thing. It's continuous learning. So that's another thing that's made it possible

16:09.600 --> 16:14.720
for customers to find information that they actually want to find and make their employees more

16:14.720 --> 16:19.360
productive. So that's sort of the top, the top layer of the stack is essentially a whole bunch

16:19.360 --> 16:25.120
of AI services. There's some foundational ones, like I said, and then there's some that are

16:25.120 --> 16:33.920
specific to domains like healthcare and industrial manufacturing domains. And then there's a lot

16:33.920 --> 16:38.240
of applications, sort of things, things that solve business problems directly.

16:39.440 --> 16:46.640
So you've described this pretty broad set of services. We want to jump into talking about

16:46.640 --> 16:51.840
code whisperer. Code whisperer is not the first AWS service that's dealing with code,

16:51.840 --> 16:54.560
right? There was code guru and then possibly others. Yes.

16:54.560 --> 17:02.880
Talk a little bit about what AWS has been doing with code and kind of how code whisperer came about.

17:04.000 --> 17:13.600
Yeah. So we've always known that AIML is going to, it's going to help a whole variety of

17:14.880 --> 17:20.000
different areas. It's going to find its way into many different areas and it's going to make

17:20.000 --> 17:26.960
things easier in those areas. I remember I think Werner Vogels, who's our CTO, he wrote a blog

17:26.960 --> 17:32.640
article on how AIML has the potential to completely change the way developers do their every day go

17:32.640 --> 17:42.800
about their every day work that they do. So the journey actually started in 2019. And if you look at,

17:42.800 --> 17:47.840
I think I should start with what is a developer's workflow look like? That's a great place to start,

17:47.840 --> 17:52.000
and then I can sort of tell you how we went about tackling all of those different pieces.

17:53.040 --> 18:00.080
So what a developer first does, of course, he writes code. That's the first sort of stuff he writes

18:00.080 --> 18:07.920
code. And then the next thing that they do is get the code reviewed by peers and some people may

18:07.920 --> 18:16.400
even use some automated systems to kind of scan the code and help find things. So that piece,

18:16.400 --> 18:22.480
you get it reviewed. And once you've reviewed the code, you deploy it, you deploy the whole thing,

18:22.480 --> 18:27.120
and then you monitor it as the application is serving the customers that it's meant to serve.

18:28.080 --> 18:34.640
And at that time, you're monitoring your applications for cost and performance, and then you'll

18:34.640 --> 18:40.880
maybe find opportunities to make those better. So those are sort of key pieces of a workflow,

18:40.880 --> 18:47.760
developer's workflow. When we started in 2019, we launched our very first service with

18:48.720 --> 18:54.720
that is related to developers and writing code. And the one we decided to launch at that time,

18:54.720 --> 19:02.000
it was CodeGuru in 2019. And what CodeGuru does is it helps you find bugs in your code,

19:02.000 --> 19:08.160
and it helps you find lines of code that are very expensive, expensive in terms of the amount

19:08.160 --> 19:14.160
to compute it would need. So that's the kind of stuff that CodeGuru helped. And so you could think

19:14.160 --> 19:22.800
of CodeGuru then as taking care of the quality of the code, the reviewing part, it helps in that

19:22.800 --> 19:30.400
part of the workflow. And is it considered an ML service or an AI service? Yeah, it is considered

19:30.400 --> 19:36.880
an AI service. So in the AI service groups at the top layer of the stack, we also have a developer

19:36.880 --> 19:43.200
focused set of services. CodeGuru was the first one, which we launched in 2019. The second one we

19:43.200 --> 19:48.880
launched was a year later, and that's DevOps guru. And this is to tackle the monitoring the

19:48.880 --> 19:53.680
application once you've deployed it, and you're monitoring it, and you're up, then you're trying

19:53.680 --> 19:58.480
to find places to optimize it, right? And so that's what DevOps guru does, and we launched that in

19:58.480 --> 20:05.760
2020. And we finally, we've now tackled the writing code part, which is what Code Whisperer is

20:05.760 --> 20:12.400
all about. And let me set up the problem a little bit more. I mean, writing code is majority

20:12.400 --> 20:19.920
of what a developer would do. And I'm still, I'm a, I've always been a very passionate developer,

20:19.920 --> 20:26.080
and I still write code, not as much as I like to, but I still write a lot of code. And so

20:26.960 --> 20:31.920
the best way to set up this problem is, is to talk through my own experience here. Like,

20:31.920 --> 20:39.280
so what I tend to do with the limited amount of time that I can get these days, I may pick a pet

20:39.280 --> 20:44.560
project that I'm either that I want to automate. And I'm doing it mainly to learn, because I know

20:44.560 --> 20:49.040
that there's new frameworks all the time. And so when I hear about something, I want to,

20:49.040 --> 20:52.800
so many new frameworks. That's right. That's right. That's right. So I just want to learn. I want to

20:52.800 --> 20:57.200
be in touch with the technology, because then, you know, I can interact better with my people,

20:57.200 --> 21:04.400
because that's what they do all day long. So, so what I tried to do, this was about, this was

21:04.400 --> 21:11.280
maybe a year and a half or a year and a half ago. I was hearing a lot about React as a framework

21:11.280 --> 21:17.360
for front-end development. And the last time I've done any, any front-end programming was back in,

21:18.080 --> 21:24.160
I mean, the 2011, 2012 timeframe when, you know, there were, there was this, you know,

21:24.160 --> 21:30.080
Microsoft had this Windows presentation foundation. There was this concept of XAML, which would separate

21:30.080 --> 21:35.600
design from, from actual implementation, the design of how the user interface would look like,

21:35.600 --> 21:40.480
from the actual implementation of what would happen when you actually trigger those, those buttons

21:40.480 --> 21:44.960
and those dropdowns, right? And so that was the last time I'd done any kind of front-end programming.

21:44.960 --> 21:48.720
But then I've heard, I heard so much about React, everybody talk about it. So I said, okay,

21:48.720 --> 21:53.920
I need to learn this too. I need to see what it, what it is. And so I picked a project that I wanted

21:53.920 --> 21:59.440
to just implement. I thought it was going to just be a weekend project. And so I learned about

21:59.440 --> 22:09.120
React. I knew Java, but JavaScript, I've not done a lot of JavaScript or TypeScript, but it was

22:09.120 --> 22:14.880
close enough. And so the first issue was, of course, programming language and the syntax and

22:14.880 --> 22:18.800
how things are. They're all different. There's so many programming languages these days.

22:18.800 --> 22:25.600
And new ones coming up all the time. And each one has its own area where it shines and other

22:25.600 --> 22:30.640
areas where it's not so great. So that's the first place. There's a difference. If you're,

22:30.640 --> 22:35.600
it's a different language that's used there. But then the framework itself, the concepts behind

22:35.600 --> 22:41.760
React and how do you use it for doing front-end. That was another thing. But it wasn't enough for

22:41.760 --> 22:46.240
me to just learn about React. The moment I, once I finished learning about React, I needed to

22:46.240 --> 22:53.360
learn about React Router, which is the thing that would route incoming calls. But that wasn't

22:53.360 --> 23:01.040
enough. I needed to learn about React Redux. And even that wasn't enough because I like to test

23:01.040 --> 23:06.800
my code. I like to, I shouldn't even say test. I'd like to specify the behavior of the code first

23:06.800 --> 23:11.040
and then actually go and implement the code. So I needed to have some testing frameworks. So

23:11.040 --> 23:16.080
just, I needed to learn about just. And that was also not enough because there's another testing

23:16.080 --> 23:21.600
framework for React called Enzyme, which is very popular. So by the, there were all these different

23:21.600 --> 23:27.440
frameworks. And by the time I had gone, I just spent a whole bunch of weekends learning a lot of

23:27.440 --> 23:32.560
these things. And I still haven't written anything meaningful. I've not made any progress

23:34.000 --> 23:39.680
on what I wanted to build, right? And so, so that's, that's a big problem that there's just so

23:39.680 --> 23:44.160
many different things that developer needs to know. And now if you take this to the cloud world,

23:45.200 --> 23:51.040
you know, with AWS, we've have 250 plus services, I think, today on AWS. That's about

23:51.680 --> 23:57.360
10,000 plus APIs, right? And by the time we finish this conversation, there'll be a few more.

23:58.240 --> 24:04.640
So, so what is a, how, what is a developer, how does he do this, right? And typically what people

24:04.640 --> 24:11.360
do is they go to stack overflow. Yeah, okay. And then you're going to look for snippets of code

24:11.360 --> 24:17.200
that you can copy paste, right? So that's the, that's the life of a developer. And it's, it's,

24:17.200 --> 24:23.840
it's, it's gotten harder. And so that's kind of where code whisperer comes in. And what code whisperer

24:23.840 --> 24:34.160
is is it's an ML powered coding companion, a pair programming companion, if you will, that just helps

24:34.160 --> 24:40.960
developers be more productive. And it doesn't matter where you are in your journey as a developer.

24:42.640 --> 24:47.840
What what code whisperer helps you accomplish, it helps you magnify your impact no matter where

24:47.840 --> 24:55.520
you are in the journey, right? And so I think that's the core, that's the core reason why we built it.

24:55.520 --> 25:01.600
Yeah, I've got to ask my, my suspicion is that, you know, most folks listening to this podcast,

25:01.600 --> 25:10.240
if not all, have heard of co-pilot, which is kind of collaboration between OpenAI and GitHub,

25:10.240 --> 25:19.600
which preceded code whisperer by sometimes six months maybe. Did they scoop you or

25:21.520 --> 25:26.080
no, I mean, so you actually helped me set this up really nicely by with your previous question,

25:26.080 --> 25:30.880
right? Like, so you, I talked to you about the journey we were on, developer tools. We started

25:30.880 --> 25:36.720
in 2019 with code group, right? So for me, this is a continuation of that of that whole journey.

25:36.720 --> 25:44.080
So you can argue who came first with that story in place, right? But let me tell you about

25:44.080 --> 25:50.000
things that we're doing differently with code whisperer. We did a few things very differently

25:50.000 --> 25:57.040
with code whisperer. The first thing we did differently, if you look at things, the other tools

25:57.040 --> 26:05.440
that are out there that do things that are similar, often you'll see headlines like a lot of the

26:05.440 --> 26:12.240
code, about 40% of the code that's generated has security problems, security issues. Security and

26:12.240 --> 26:16.080
licensing are the things that come up quite a bit. So I'm going to tackle security first,

26:16.080 --> 26:22.480
but then I'll come to licensing. So you're hitting all the sweet spots right now. So yeah, so it's

26:22.480 --> 26:29.520
on security. So what we do is as part of code whisperer, which by the way, it's part of the AWS

26:29.520 --> 26:36.240
toolkit. And the toolkit is a plug-in to all the major IDs. So it's, we've got plugs into

26:36.240 --> 26:42.320
which was studio code. It also plugs into all the JetBrains IDs. So it's, I think, PyCharm for Python

26:42.320 --> 26:50.560
and IntelliJ for Java and WebStorm. And primarily to do completion for APIs and that kind of thing.

26:50.560 --> 26:56.560
Yes. And it's, or initially, if not, yeah, we're not talking about completion, like, you know,

26:56.560 --> 27:02.080
like the way IntelliSense used to be. We're talking about like 20 lines of code and 25 lines of

27:02.080 --> 27:07.840
code. So when we get to the demo at the end, you'll see that I was speaking more generally about

27:07.840 --> 27:16.240
the IDE toolkit that preceded code whisperer. Correct. Or is that? Oh, the AWS toolkit has been

27:16.240 --> 27:23.200
there for a long time. Right. And that was primarily created to make those IDs aware of the AWS

27:23.200 --> 27:28.240
API. Exactly. Exactly. Or completion and things like that. Exactly. Okay. Now it's just like

27:28.240 --> 27:33.680
completion at another level. That's right. You will show us. Absolutely. Absolutely. Yeah.

27:33.680 --> 27:39.280
That's true. So and what people just need to do is just download the AWS toolkit and they have

27:39.280 --> 27:45.680
it as part of these IDs. We also integrated code whisperer into our Lambda console. So Lambda is

27:45.680 --> 27:52.400
our serverless service. So it's where you just type in code and there's no servers to manage.

27:52.400 --> 27:57.120
Your code just runs and gives you the results. Right. And so there's a lot of code that's being

27:57.120 --> 28:02.080
written on the Lambda console. So it's plugged in there. It's also built in a cloud nine yet.

28:02.080 --> 28:06.880
Yes, it is. Okay. It comes with integration into cloud nine as well. That's our web web based

28:06.880 --> 28:14.000
ID. So we were on a topic and I dig dig rest and went into this one. Yeah, the differentiators.

28:14.000 --> 28:19.920
Right. So this the first one is this the security security thing. Like for us at AWS

28:19.920 --> 28:26.080
security is like job zero. I'm sure you've heard a lot about how seriously we take security.

28:26.080 --> 28:31.680
And we think we need to help because security is a very specialized skill. Most companies have

28:32.160 --> 28:39.520
you know a separate group of experts that are just there for you know for this topic in general.

28:39.520 --> 28:43.920
And so we have what's called a security scan that's built into code whisperer. So

28:43.920 --> 28:51.760
you can you could write code and then you could you could accept a lot of the code whisperer

28:52.480 --> 28:56.960
suggestions. And you can also edit it further. But at the very end we've got the security scan

28:56.960 --> 29:01.200
thing that you can hit. And it's going to tell you if there are any security issues in the code

29:01.200 --> 29:06.480
that that it's scanned. So that's the first thing that we've done differently. We want to make

29:06.480 --> 29:12.800
sure that the code we generated the code that ends up coming out at the other end. We want to

29:12.800 --> 29:19.920
help in as many ways as we can to make sure that it has the it doesn't have any security issues.

29:19.920 --> 29:25.520
And presumably that security scan is also an ML model that's trained and recognized

29:25.520 --> 29:28.400
potential security issues. Absolutely. Yeah. Yeah.

29:29.360 --> 29:34.560
Code guru had this capability when we launched it in 2019. And so we're we're using a lot of

29:34.560 --> 29:41.040
that here as well. Okay. So that's the first area where it's different. And the second area where

29:41.040 --> 29:49.120
it's different is in terms of the code it generates. I'm sure you've heard of like AI systems like

29:50.160 --> 29:56.160
with games like chess and go. These they come up with new moves that they've never seen before or

29:56.160 --> 30:01.120
new strategies they've never seen before. And to a large extent that's what happens when code

30:01.120 --> 30:06.560
whisperer is generating code. It's generating code it's not seen before. But there may be instances

30:06.560 --> 30:11.840
where the code that it generates is close enough to something that it's seen before. And

30:11.840 --> 30:16.240
code whisperer of course is trained on billions of lines more than billions of lines of code from

30:16.240 --> 30:22.880
public repositories from Amazon repositories code repositories from documentation and forums

30:22.880 --> 30:28.640
public forums. And that's it's trained on a lot of stuff. So it may have seen something similar

30:29.280 --> 30:34.560
before. And then what code whisperer will do is it provides what we call a reference tracker

30:34.560 --> 30:42.400
where it lists the license under which that other similar piece of code was provided. So this

30:42.400 --> 30:49.760
way developers know that the code that is there could potentially have that license so they can

30:49.760 --> 30:54.080
decide whether they want to include that piece of code or they want to accept that suggestion or

30:54.080 --> 30:58.960
they don't want to it depends on you know what the what the company rules are and it depends on

30:58.960 --> 31:03.920
things like that. So that's the second thing that we're doing differently. And the third thing that

31:03.920 --> 31:14.400
we're doing differently is like we talked about the the number of AWS services. And so first class

31:14.400 --> 31:21.120
support for AWS APIs. We know what the most common patterns are in terms of application developers and

31:21.120 --> 31:28.960
how they use the cloud. And now you can you can without having to learn about the 10,000 plus APIs

31:28.960 --> 31:34.720
without having to worry about any of that your intent you just express your intent as you will see

31:34.720 --> 31:41.840
later you express your intent either in the form of a good name for the function or in the form of a

31:41.840 --> 31:48.080
comment. And we're just going to give you the best pieces of code that would make the most sense

31:48.080 --> 31:55.760
and that point. So those are some of the differences. We're also pretty we do some aggressive

31:55.760 --> 32:04.080
filtering on on potential harmful stuff. And so we're also we've taken a lot of effort to

32:04.080 --> 32:10.320
minimize any issues there as well. So these are all the differences for code whisperer at this point

32:10.320 --> 32:19.280
in time. You talked about the sources of code that the code whisperer was trained on. You spoke

32:19.280 --> 32:27.040
about them broadly is GitHub included in that that set of repositories anything that's public and

32:27.040 --> 32:33.680
has the right license. That's what we use. And are there specific licenses or types of licenses

32:33.680 --> 32:40.080
that you filtered on? Definitely the the pieces of code that are public and are available for

32:40.080 --> 32:46.480
consumption. Those are part of the training corbis as well as all of the Amazon code internally that

32:46.480 --> 32:52.720
we've had from over many years. That's part of the that's part of it as well. And anything that's

32:52.720 --> 32:59.520
public and like documentation that's public. Those are all pieces of code that goes into the training.

33:00.080 --> 33:08.160
I'm imagining that if you're scouring the web crawling the web looking for code

33:08.160 --> 33:15.840
that even the you know identifying code identifying the licenses associated with that code presents

33:15.840 --> 33:20.880
interesting machine learning problems. Absolutely absolutely yeah. There's a lot of classification

33:20.880 --> 33:26.320
problems right there right. A whole class of classification problems just on figuring out

33:26.880 --> 33:30.240
which are the ones that you want to use and which are the ones you don't want to use. And of

33:30.240 --> 33:35.680
course we've we've used every every technique that we've already have. I've talked about many of our

33:35.680 --> 33:41.600
AI services at the top layer of the stack. Comprehend for example has a document classification API.

33:42.960 --> 33:47.680
Essentially what you do there is that you decide what you're what you want to call your category and

33:47.680 --> 33:52.640
you give it examples of a certain document that belong to the category. Some number of documents

33:52.640 --> 33:57.280
that belong to the category define a category two. Another set of documents that belong to that

33:57.280 --> 34:01.600
category and then you could define a third category called other where you give it a whole bunch of

34:01.600 --> 34:07.120
documents that have no particular category. And then Comprehend will train a custom model for you

34:07.120 --> 34:11.200
and you're not an ML you don't have to be an ML export for it. It's just not accessible through

34:11.200 --> 34:17.520
the APIs and then you have now an endpoint where you can send it new documents and it's going to

34:17.520 --> 34:23.760
tell you is it class one or class two or class three and so we we have a lot of these techniques

34:23.760 --> 34:30.000
already in place and we've used that a lot for these kinds of things. Okay. Okay. Presumably this

34:30.000 --> 34:35.520
is based on a large language model like other implementations of code generation

34:37.680 --> 34:46.160
in the text textual context of LLM's one of the big conversations is around bias and

34:46.160 --> 34:51.680
kind of responsible use of those. Yeah. Did those same kinds of issues surface when we're talking

34:51.680 --> 34:57.600
about code and if so how? Yeah. So if you if you look at a lot of the transform models

34:57.600 --> 35:02.800
they've got you know they're built on top of each other so there's various checkpoints.

35:03.600 --> 35:08.720
Typically you would have a large language model that's trained on just text and then you

35:08.720 --> 35:13.600
would that would be a checkpoint and then you would take that and then now train it on code.

35:13.600 --> 35:20.080
Right. So if if there's issues with that core based model they're probably going to linger on

35:20.080 --> 35:29.040
and so we've got if you go to amazon.science it's a it's a it's a one of the websites and

35:29.600 --> 35:35.920
you'll see that we published just in the last year alone we published about 400 papers on

35:35.920 --> 35:41.280
responsibly I that deals with all of these topics which we take very seriously things like bias

35:41.280 --> 35:49.200
and fairness. We have in in my team we've got we've got the person that wrote the book on algorithmic

35:49.200 --> 35:56.960
bias. He's a professor at UPEN his name is Michael Kerns he'll meet him later today and so

35:58.160 --> 36:04.560
we've got all of those experts helping us avoid the pitfalls as much as possible. Now this is of

36:04.560 --> 36:09.600
course an emerging it's a it's a thing that's still progressing it's not like we know exactly

36:09.600 --> 36:15.760
what we need to do here but we've got the best minds looking at these topics and helping us

36:15.760 --> 36:22.640
figure out how best to deal with those situations. I didn't mention some very aggressive filtering

36:22.640 --> 36:27.520
that we're doing to prevent those kinds of situations those kinds of things were implemented

36:27.520 --> 36:38.400
with the guidance of folks like Michael. I'm imagining the kind of classic profanity in comments

36:38.400 --> 36:45.600
is one example is example but are there other yeah I was kind of trying to get some examples of the

36:45.600 --> 36:52.640
way bias types of issues might surface in a code code specific context are there examples that

36:52.640 --> 36:56.400
come to mind of that. Yeah generally if you're let's say you're writing a function that takes

36:56.400 --> 37:02.160
an agenda and makes a decision based on the gender there could be areas where bias can creep in

37:02.160 --> 37:06.480
and so you've got to explicitly look for situations like that and make sure you don't generate

37:06.480 --> 37:13.280
codes along those paths and that's one another one is of course keys right like so we're talking

37:13.280 --> 37:21.200
about APIs in the cloud a common thing that I see happen a lot is just keys where your secret keys

37:21.200 --> 37:27.440
and your and developers tend to sometimes just put it into the source file including the ones

37:27.440 --> 37:32.640
checked into GitHub right there's a lot of your keys are in there right right and now if you're

37:32.640 --> 37:38.800
learning from all of that and let's say you do want to generate you do want to generate that

37:38.800 --> 37:45.920
line it could up like you could leak potential key right and so we've taken a lot of care to prevent

37:45.920 --> 37:50.400
those kinds of situations and I'll probably be able to show you that as well when when we actually

37:50.400 --> 37:57.280
get to the demo in the end. Awesome awesome well this may be a great segue to the demo before we do

37:57.280 --> 38:03.840
any any additional thoughts you want to share before we jump into the demo. No I just think that

38:03.840 --> 38:09.040
I told you that I was like I'm a very passionate developer and a developer and still am

38:10.160 --> 38:16.720
I really think that this is just the beginning of what we can we're going to be able to do

38:16.720 --> 38:21.200
and this is going to make developers lives a lot more easier and I think they can focus most

38:21.200 --> 38:26.960
developers that I know they want to focus on the the higher value problem they're less interested

38:26.960 --> 38:32.800
in the boilerplate you know things that a framework may dictate and that's that's the that's

38:32.800 --> 38:38.800
the bad part of writing code it's the the the real cool part is the is the business logic the

38:38.800 --> 38:44.640
that's the cool parts that you want to actually write and so I think this is going to be this is

38:44.640 --> 38:47.920
going to be in a space to watch going forward there's going to be a lot of innovation coming

38:48.720 --> 38:54.800
on this topic and I just I'm very excited for what's to come in this area. No just to probe into

38:54.800 --> 39:02.240
that a little bit do you do you have a gut feel for where you think the innovation will come first

39:02.240 --> 39:07.920
or kind of what the you know what the path looks like. We've got some ideas on where the path looks

39:07.920 --> 39:14.080
like and I'm sure you know that like 90% of what we do it it it it is driven by our customers it's

39:14.080 --> 39:20.160
what they're asking us for and about 10% of the time we think on their behalf and and we do

39:20.160 --> 39:28.080
something right based on that the obvious next steps will just be support for the more popular

39:28.880 --> 39:36.480
languages I think we're currently support TypeScript JavaScript Java Python is what we support

39:36.480 --> 39:40.800
so obviously there's going to be an element of supporting some of the key languages that's

39:40.800 --> 39:46.720
definitely going to be one that's going to be there but I think it's just going to get better

39:46.720 --> 39:54.400
and better in terms of in terms of the actual code that's generated today developers can accept

39:54.400 --> 40:00.480
you know they can accept there's going to be options so when when code whisperer generates

40:01.600 --> 40:06.960
generates code it gives you it gives you x number of options you can actually scroll through it

40:06.960 --> 40:13.360
and see which one sort of fit your style and and what do you want to include those those suggestions

40:13.360 --> 40:21.520
will get better over time and I think it just make people's lives a lot easier and best practices

40:21.520 --> 40:28.000
you know we can capture best practices I mentioned already we kind of know the patterns of how

40:28.000 --> 40:35.600
AWS APIs are accessed for application development and if you use there's best practices in terms of

40:35.600 --> 40:41.120
how you put them together how you do error checking and things like that and so those things can

40:41.120 --> 40:47.360
come more and more out of the box and this will this will make it easier for even you know developers

40:47.360 --> 40:55.520
that are earlier in their journey to generate pieces of code that are pretty robust so that's

40:55.520 --> 41:00.480
pretty much what I can share at this point in time awesome awesome well let's let's jump into the

41:00.480 --> 41:04.720
demo okay all right what are we looking at here Vassie all right you're looking at

41:04.720 --> 41:10.960
uh jet rains pie charm and I think this one because python is not a language that I like but

41:10.960 --> 41:18.000
that that's exactly why why you know code whisperer is very useful um so let me let me just alienate it

41:18.000 --> 41:24.080
I know I know I know I know I know I just don't like be able to redeem yourself by saying you love

41:24.080 --> 41:33.360
Julian okay all right all right um anyway um so I'm gonna be doing a series of demos and each one

41:33.360 --> 41:40.960
sort of takes it up a notch a little bit that's what I'm gonna try and do here um so the first one

41:40.960 --> 41:45.760
it's it's kind of going to be a utility kind of thing that I think most developers want to do what's

41:45.760 --> 41:52.800
they end up doing at some point um right so um code whisperer is enabled and the AWS toolkit has

41:52.800 --> 41:57.840
been installed you guys can see it on the left side of the screen um so I'm gonna just start by saying

41:57.840 --> 42:12.960
um a function to convert a JSON file to and I you see code whisperer just popped up

42:13.520 --> 42:21.680
even my comment all right um so I'm just gonna accept that and um I want to specify a few more

42:21.680 --> 42:30.800
things like I want to say things like um the keys of the JSON file are the column names again

42:30.800 --> 42:36.240
you see that code whisperer popped that up I'm gonna accept that as well and then I don't care

42:36.240 --> 42:43.680
about the values much um and now let's see let's see what code whisperer does it just generates

42:43.680 --> 42:55.360
the function name um I'm just gonna accept it um and there is a set of code a bunch of code that

42:55.360 --> 43:02.080
it just popped up um and then you can see this little thing at the bottom and that those are the

43:02.080 --> 43:08.320
choices it says one of four and so I could probably go through the various options it's given me

43:08.320 --> 43:18.240
um and and try and pick the one that I like the most and I'm probably gonna pick this one um it's

43:18.240 --> 43:22.800
you can see what it's doing here it's taking the keys it's writing the header with the keys just

43:22.800 --> 43:29.440
like we said and then it's writing all the rows so I'm just gonna pick that um and so I guess

43:30.000 --> 43:36.320
that's kind of done I don't want to print anything and then let's if we just go in here to an empty

43:36.320 --> 43:44.160
area and then see what else it's going to you can see that what it did here is now it's it's saying

43:44.160 --> 43:49.040
a function to convert a CSV file to a JSON file so it's the opposite of what we just did which is a

43:49.040 --> 43:54.960
common thing that most developers do like they um they write a transformation from one side to the

43:54.960 --> 44:00.880
other and it's very likely you want the transformation from the other side as well so um we can

44:00.880 --> 44:06.400
continue doing that and we'll see what happens here I don't I don't want that thing so

44:10.560 --> 44:16.080
and there's the function name CSV to JSON I accept it and then I keep going

44:17.680 --> 44:23.920
and again I've got a bunch of options here um you can see it uses a dict reader on on the CSV data

44:23.920 --> 44:29.360
and then it's dumping it into the JSON file I could just accept that and I'd be done with it so

44:29.360 --> 44:33.760
that's sort of the first little demo that I wanted to start with so that you get used to the

44:33.760 --> 44:43.280
interface you kind of see what happens yeah um what I'll do next is um I'll I'll go to a more

44:43.280 --> 44:49.760
obscure API um and I say obscure because most most developers that use AWS they've used the s3

44:49.760 --> 44:56.000
they want the typical examples are upload a file to s3 or um they're doing some EC2 stuff right and

44:56.000 --> 45:02.240
so um transcribe is one of my services the speech to text service um unless you are an AI developer

45:02.880 --> 45:06.880
or unless you're a developer that wants AI in your app you probably won't know about it and

45:08.080 --> 45:15.280
it's and so this is a situation exactly like that um so what I'll start with and because we're

45:15.280 --> 45:22.640
going to be demonstrating use of an AWS API here um I'll start with uh you know variables for

45:22.640 --> 45:34.720
AWS credentials right um and you can see there's the access key but you also see that it's not

45:34.720 --> 45:41.360
giving me the key itself and even though it may have seen some keys in the training data um there's

45:41.360 --> 45:50.160
a secret key probably a region and I guess I don't care anymore um then the next thing I'll do is

45:50.160 --> 46:02.240
um write a function to transcribe uh I have to type right transcribe a German you put it popped up

46:02.240 --> 46:09.760
audio file but I want to say a German audio file to text and you can see it popped that as well right

46:11.760 --> 46:17.600
so it's giving me the name of the function I accepted it and this is going to be some elaborate

46:17.600 --> 46:25.200
it's going to just going to be more elaborate so we just wait for it um you can see a lot of stuff

46:25.200 --> 46:31.600
happening here um the bottom client is created with the transcribe thing that's typically how you

46:31.600 --> 46:36.880
can see that the access keys and the secret keys in the region from above that variables are being

46:36.880 --> 46:44.800
used to generate that that um that variable and then you can see the cool thing here it understands

46:44.800 --> 46:53.840
the locale uh it's d-d and so it's there's uh you don't have to look up the documentation there's a

46:53.840 --> 47:01.600
transcribe start transcription job right and then here it returns the job um right and so um there's

47:01.600 --> 47:07.360
probably more options um there's probably more options down there um but I'm just going to

47:07.360 --> 47:14.160
know if you yeah speaking of options if you knew a little bit about transcribe and say previously yeah

47:14.160 --> 47:18.640
define the variable with the channel type which is one of those parameters that transcribe will take

47:18.640 --> 47:21.440
yeah yeah uh would it have inserted that in the right place?

47:21.440 --> 47:27.520
yes absolutely so the way it what code whisperer works is it gets context in the call and the

47:27.520 --> 47:36.800
context for it is depends on where the cursor is it's code code around that cursor um and it could

47:36.800 --> 47:42.480
even be code in other files in the project and so it uses that to figure out what's the best way

47:42.480 --> 47:46.640
to do it and some of the options may include it some of the options may not include it all right

47:47.280 --> 47:54.640
so that's kind of how it works um so let me let me accept this and maybe what I rather than

47:54.640 --> 48:03.120
returning the the transcribe job maybe what I could do is um you know just delete this thing here

48:03.120 --> 48:09.440
um and see what what it would generate maybe it would generate the same thing um but

48:10.240 --> 48:14.000
okay wait for the transcription to complete um okay while true

48:16.080 --> 48:21.440
and let's see what happens yeah okay so it's it's actually parsing the thing

48:22.560 --> 48:28.400
going into it multiple levels to figure out the status sleeping for a while and and so on and so

48:28.400 --> 48:34.880
forth and um so you could keep going uh with this and it's discoverability of these APIs it's

48:34.880 --> 48:38.880
it's now a lot easier you don't have to go to stack overflow and look for the snippet the snippets

48:38.880 --> 48:44.400
right there on the ID all right so that's the second demo that I wanted to show and I wanted to

48:44.400 --> 48:50.480
show how it would work on a on an AWS API that's not very common for people to know about um then

48:50.480 --> 48:56.000
the last thing that I probably would do and this is where we let's actually create something that

48:56.000 --> 49:05.120
we actually run and see if it works right and so um and what I'm gonna try and do is um write a

49:05.120 --> 49:25.360
function to plot sign of sign of x and let's say two star cosine of x come on with red and blue dashes

49:26.400 --> 49:34.480
for the range minus pi to pi all right that's a lot of stuff yeah we always have to

49:34.480 --> 49:41.360
pray to the demo gods so to speak and yeah uh but you would think that that given the the nature

49:41.360 --> 49:48.320
of what's happening it'd be fairly robust uh typos is that what you find in general um I in general

49:48.320 --> 49:52.480
I'm when I'm writing code I'm writing it for the next person that's going to be looking at it more

49:52.480 --> 49:57.760
than anything else so I there's this whole philosophy and I can talk about it for hours

49:57.760 --> 50:06.080
um a good code base is is one where um let's say you have a new developer in the team that person

50:06.080 --> 50:11.680
can add a new feature in the shortest amount of time and I think that's possible only if your

50:11.680 --> 50:19.360
code base is self-explanatory it's decoupled isolated things responsibilities are isolated um so yeah

50:19.360 --> 50:24.880
I I even if I you could say okay why can't we correct the typos maybe that would be a future

50:24.880 --> 50:30.880
thing that we do it should be possible to do I don't see a reason um why that won't work but in

50:30.880 --> 50:36.560
general the context is a lot of stuff and so if let's say there's a spelling error in fact you know

50:36.560 --> 50:41.360
what what I'm going to do right now um let me actually take this let me actually mess around with

50:41.360 --> 50:46.480
it I don't want that argument um right so it generated that I'm actually going to change that

50:46.480 --> 50:52.560
and now let's see what it does it just generated all that stuff right and you can see it's using

50:52.560 --> 50:59.360
minus pi to pi and it's got the red dashes on red dash on sign and the the blue on the

51:00.160 --> 51:07.040
let me just accept it and then if I go here um yeah so it's calling that function so

51:08.000 --> 51:14.800
now if I just run this thing let's see what happens if it's even correct and there it is all right

51:14.800 --> 51:21.680
so you see you see the um the program actually running so that's kind of the the last thing

51:21.680 --> 51:29.520
that I wanted to show that um it can do things that are pretty elaborate and um in the end though

51:29.520 --> 51:33.840
the the developer is responsible for the code and I think the person needs to know

51:34.480 --> 51:41.200
what to accept you know with the options um how does he want to take this further so that's why

51:41.200 --> 51:46.720
we call it a uh it's more of a companion than it's not the thing leading the way it's the thing

51:46.720 --> 51:53.200
that's helping you not have to go look look things up in multiple places yeah um so that's your

51:53.200 --> 51:59.920
typo not right right but I think that's definitely something that we should be able to handle um

51:59.920 --> 52:03.040
so you've just given me a good idea for our roadmap

52:05.760 --> 52:13.840
cool um that's all I had um to show well Vasi uh great conversation and great demo thanks so much

52:13.840 --> 52:20.240
for uh taking the time to share with us a bit about code whisperer and more broadly the

52:20.240 --> 52:24.640
AI services portfolio and the way you think about all those things it was a pleasure thanks for

52:24.640 --> 52:52.640
having me sir my pleasure thank you all right bye bye

